// =============================================================================
// SEMANTIC LAYER TYPES (LLM-generated nodes for layers 1-3)
// =============================================================================

export type SemanticLayer = 'system' | 'domain' | 'module'

/**
 * Base interface for all semantic nodes (layers 1-3)
 * These are generated by the LLM analyzing the codebase structure
 */
export interface SemanticNode {
  /** Unique ID (format: layer:name, e.g., "module:auth" or "domain:user-management") */
  id: string
  /** Human-readable name */
  name: string
  /** Short summary of what this semantic unit represents */
  summary: string
  /** Which layer this node belongs to */
  layer: SemanticLayer
  /** ID of the parent node (for border color inheritance) */
  parentId?: string
  /** IDs of child nodes (lower layer or symbols for modules) */
  children: string[]
  /** Optional metadata */
  metadata?: {
    /** File path patterns that belong to this unit */
    filePatterns?: string[]
    /** Key concepts/keywords */
    keywords?: string[]
    /** Primary responsibility */
    responsibility?: string
  }
}

/**
 * Mapping configuration for what code belongs to a construct/module
 * Uses an inheritance system: directory → file → symbol (with cascading overrides)
 */
export interface ConstructMapping {
  /**
   * Directory patterns mapped to this construct
   * - Use * for direct children only (e.g., "src/api/*" matches files in src/api/ but not subdirs)
   * - Use ** for recursive (e.g., "src/api/**" matches all files under src/api/)
   */
  directories?: string[]
  /**
   * Specific files mapped to this construct
   * Overrides any parent directory mapping
   */
  files?: string[]
  /**
   * Specific symbols mapped to this construct (format: "filePath:symbolName")
   * Overrides any file/directory mapping for these specific symbols
   */
  symbols?: string[]
}

/**
 * Module node (Layer 3) - Groups of related symbols
 * Example: "Authentication Module", "API Client Module"
 */
export interface ModuleNode extends SemanticNode {
  layer: 'module'
  /**
   * @deprecated Use mappings instead. Symbol IDs for backwards compatibility.
   */
  children: string[]
  /**
   * New mapping system for construct-to-symbol relationships
   * Supports directory, file, and symbol-level granularity
   */
  mappings?: ConstructMapping
}

/**
 * Domain node (Layer 2) - Business domains
 * Example: "User Management", "Payment Processing"
 */
export interface DomainNode extends SemanticNode {
  layer: 'domain'
  /** Module IDs that belong to this domain */
  children: string[]
}

/**
 * System node (Layer 1) - High-level architectural components
 * Example: "Frontend", "Backend API", "Database Layer"
 */
export interface SystemNode extends SemanticNode {
  layer: 'system'
  /** Domain IDs that belong to this system component */
  children: string[]
}

/**
 * Edge between semantic nodes
 * Note: 'contains' is eliminated - use parentId/children hierarchy instead
 */
export interface SemanticEdge {
  id: string
  source: string // SemanticNode ID
  target: string // SemanticNode ID
  type: 'depends-on' | 'communicates-with'
}

/**
 * Complete semantic analysis result from LLM
 */
export interface SemanticAnalysis {
  /** Project identifier (absolute path) */
  projectPath: string
  /** When the analysis was generated */
  timestamp: string
  /** Version of the analysis schema */
  version: string
  /** System-level nodes (Layer 1) */
  systems: SystemNode[]
  /** Domain-level nodes (Layer 2) */
  domains: DomainNode[]
  /** Module-level nodes (Layer 3) */
  modules: ModuleNode[]
  /** Edges between semantic nodes */
  edges: SemanticEdge[]
}

/**
 * Cache manifest for tracking validity
 */
export interface CacheManifest {
  /** Schema version for migrations */
  version: string
  /** When the cache was last updated */
  lastUpdated: string
  /** Hash of the project structure for quick invalidation check */
  projectHash: string
  /** File count at time of analysis */
  fileCount: number
  /** Individual file hashes for precise invalidation */
  files: Array<{
    path: string
    hash: string
  }>
}

// =============================================================================
// SYMBOL EXTRACTION TYPES
// =============================================================================

/**
 * The kind of symbol extracted from TypeScript code
 */
export type SymbolKind =
  | 'function'
  | 'class'
  | 'interface'
  | 'type'
  | 'enum'
  | 'constant'
  | 'variable'
  | 'object'

/**
 * A function parameter with optional type reference
 */
export interface ParameterInfo {
  /** Parameter name */
  name: string
  /** Symbol ID of the parameter type (if it references a project symbol) */
  typeId?: string
  /** Raw type text (for display when typeId is not available) */
  typeText?: string
}

/**
 * A single symbol extracted from a TypeScript file
 */
export interface ExtractedSymbol {
  /** Unique ID: filePath:name */
  id: string
  /** Symbol name (e.g., "getUserById", "UserService") */
  name: string
  /** Type of symbol */
  kind: SymbolKind
  /** Relative path from project root */
  filePath: string
  /** Starting line number (1-indexed) */
  startLine: number
  /** Ending line number (1-indexed) */
  endLine: number
  /** Whether the symbol is exported */
  exported: boolean
  /** Start column (0-indexed) */
  startColumn: number
  /** End column (0-indexed) */
  endColumn: number
  /** JSDoc description (markdown) */
  description?: string
  /** Symbol ID of the return type - for functions only (if it references a project symbol) */
  returnTypeId?: string
  /** Raw return type text - for functions only (for display when returnTypeId is not available) */
  returnTypeText?: string
  /** Function parameters - for functions only */
  parameters?: ParameterInfo[]
}

/**
 * All symbols from a single file
 */
export interface FileSymbols {
  /** Relative path from project root */
  filePath: string
  /** List of symbols in this file */
  symbols: ExtractedSymbol[]
}

/**
 * Type of edge relationship
 */
export type EdgeType =
  | 'call'
  | 'component-use'
  | 'global-read'
  | 'global-write'
  | 'class-instantiation'
  | 'enum-use'

/**
 * A dependency relationship between two symbols
 */
export interface DependencyEdge {
  /** Unique edge ID: "source->target" */
  id: string
  /** Source symbol ID (filePath:name) - the symbol that depends */
  source: string
  /** Target symbol ID (filePath:name) - the symbol being depended on */
  target: string
  /** Type of relationship */
  type: EdgeType
  /** Where the dependency occurs */
  location: {
    file: string
    line: number
  }
}

/**
 * @deprecated Use DependencyEdge instead
 */
export type CallEdge = DependencyEdge

/**
 * Complete project symbol extraction result
 */
export interface ProjectSymbols {
  /** Absolute path to project root */
  projectRoot: string
  /** All files with their symbols */
  files: FileSymbols[]
  /** Call relationships between symbols */
  callEdges: CallEdge[]
  /** Total number of symbols across all files */
  totalSymbols: number
  /** Total number of files scanned */
  totalFiles: number
  /** Files that had parsing errors */
  errors: FileParseError[]
}

/**
 * Error encountered while parsing a file
 */
export interface FileParseError {
  filePath: string
  error: string
}

/**
 * Options for symbol extraction
 */
export interface ExtractorOptions {
  /** File extensions to include (default: ['.ts', '.tsx']) */
  extensions?: string[]
  /** Directories to exclude (default: ['node_modules', '.git', 'dist', 'out']) */
  excludeDirs?: string[]
  /** Maximum depth to recurse (default: Infinity) */
  maxDepth?: number
}

/**
 * Default extractor options
 */
export const DEFAULT_EXTRACTOR_OPTIONS: Required<ExtractorOptions> = {
  extensions: ['.ts', '.tsx'],
  excludeDirs: ['node_modules', '.git', 'dist', 'out', 'build', '.next', 'coverage'],
  maxDepth: Infinity
}

// =============================================================================
// 5-STEP SEMANTIC ANALYSIS TYPES
// =============================================================================

/**
 * Analysis steps for the 5-step pipeline
 * Steps 1-3 use LLM, Steps 4-5 are algorithmic
 */
export type AnalysisStep = 1 | 2 | 3 | 4 | 5

/**
 * Step 1 Result: System identification
 */
export interface Step1SystemsResult {
  step: 1
  timestamp: string
  systems: SystemNode[]
}

/**
 * Step 2 Result: Module identification with code mappings
 */
export interface Step2ModulesResult {
  step: 2
  timestamp: string
  modules: ModuleNode[]
}

/**
 * Step 3 Result: Domain inference from systems + modules
 */
export interface Step3DomainsResult {
  step: 3
  timestamp: string
  domains: DomainNode[]
}

/**
 * Step 4 Result: Module dependencies from symbol call edges (algorithmic)
 */
export interface Step4ModuleEdgesResult {
  step: 4
  timestamp: string
  edges: SemanticEdge[] // module -> module, type: "depends-on"
}

/**
 * Step 5 Result: Domain dependencies from module edges (algorithmic)
 */
export interface Step5DomainEdgesResult {
  step: 5
  timestamp: string
  edges: SemanticEdge[] // domain -> domain, type: "depends-on"
}

/**
 * Combined edges from all dependency inference steps (4-5 + system edges)
 */
export interface AlgorithmicEdges {
  moduleEdges: SemanticEdge[] // From step 4
  domainEdges: SemanticEdge[] // From step 5
  systemEdges: SemanticEdge[] // Computed from domain edges (step 5 extension)
}

/**
 * Per-step cache entry for resumable analysis
 */
export interface StepCacheEntry {
  step: AnalysisStep
  timestamp: string
  completed: boolean
  projectHash: string
  data:
    | Step1SystemsResult
    | Step2ModulesResult
    | Step3DomainsResult
    | Step4ModuleEdgesResult
    | Step5DomainEdgesResult
}

/**
 * Extended cache manifest for 5-step analysis
 */
export interface StepAnalysisCacheManifest {
  version: string
  lastUpdated: string
  projectHash: string
  fileCount: number
  files: Array<{ path: string; hash: string }>
  /** Which steps have been completed */
  completedSteps: AnalysisStep[]
  /** Step dependency tracking */
  stepDependencies: {
    1: null // Step 1 has no dependencies
    2: [1] // Step 2 depends on Step 1
    3: [1, 2] // Step 3 depends on Steps 1 & 2
    4: [2] // Step 4 depends on Step 2 (modules) + symbol extraction
    5: [3, 4] // Step 5 depends on Steps 3 (domains) & 4 (module edges)
  }
}
